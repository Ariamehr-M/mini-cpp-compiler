# مینی کامپایلر ++C (پشتیبانی از دستورات شرطی if-else و حلقه‌ی for)

هدف من در این پروژه، طراحی و پیاده‌سازی یک کامپایلر برای یک زبان برنامه‌نویسی ساده مشابه ++C بود. برای توسعه‌ی این کامپایلر از پکیج‌های تولید کامپایلر Lex و Yacc استفاده کردم و یک رابط کاربری گرافیکی (GUI) ساده هم با ++C براش توسعه دادم. 

این مینی کامپایلر رو به عنوان پروژه‌ی درس "طراحی کامپایلر" (Compiler Design) نوشتم. تمرکز اصلی این پروژه روی تولید کد میانی (Intermediate Code) برای ساختارهای مشخصی از زبان برنامه‌نویسی است. این کامپایلر به‌خوبی از پس پردازش دستورات شرطی، حلقه‌ها و عملگرهای سه‌گانه (Ternary Operator) برمیاد. کارکرد اصلی کامپایلری که پیاده‌سازی کردم، تولید یک کد میانی بهینه‌سازی‌شده برای سورس‌کد ورودی ++C هست که طی مراحل زیر انجام میشه:

* تولید جدول نمادها (Symbol Table) پس از ارزیابی عبارات
* ساخت درخت نحو انتزاعی (Abstract Syntax Tree - AST) برای کد
* تولید کد سه آدرسه (3-Address Code) و در ادامه ساخت چهارگانه‌ها (Quadruples) مربوطه
* انجام بهینه‌سازی کد (Code Optimization)

ابزارهای اصلی که در این پروژه به کار بردم شامل **LEX** (برای تشخیص الگوهای از پیش‌تعریف‌شده و تولید توکن‌ها برای الگوهای تطبیق‌یافته) و **YACC** (برای پارس کردن ورودی از نظر معنایی، تولید درخت AST و کد میانی برای سورس‌کد) هستن. همچنین برای بخش بهینه‌سازی کد میانیِ تولیدشده توسط پارسر، از زبان **پایتون (Python)** استفاده کردم.

## استراتژی طراحی و پیاده‌سازی

### ۱. ایجاد جدول نمادها (SYMBOL TABLE)
در طراحی جدول نمادها، علاوه بر ارزیابی عبارات، سیستم تشخیص خطا رو هم پیاده‌سازی کردم. این بخش می‌تونه متغیرهای تعریف‌نشده، تعریف مجدد متغیرها و خطاهای سینتکسی (مثل فراموش کردن نقطه‌ویرگول) رو به‌خوبی مدیریت و شناسایی کنه.

### ۲. تولید کد میانی (INTERMEDIATE CODE GENERATION)
تولیدکننده‌ی کد میانی، ورودی خودش رو از فاز قبلی (تحلیل‌گر معنایی) در قالب یک درخت نحو حاشیه‌نویسی‌شده (Annotated Syntax Tree) دریافت می‌کنه. سپس این درخت به یک نمایش خطی تبدیل میشه. کدهای میانی تولید شده در این پروژه، کدهایی کاملاً مستقل از ماشین (Machine-Independent) هستند.

### ۳. بهینه‌سازی کد (CODE OPTIMIZATION)
در بخش بهینه‌ساز کد، یک نگاشت کلید-مقدار (Key-Value) مشابه ساختار جدول نمادها پیاده‌سازی کردم تا بتونم متغیرها و مقادیرشون رو (پس از ارزیابی عبارات) رهگیری کنم. از این ساختار برای انجام تکنیک‌های Constant Propagation و Constant Folding در بلوک‌های متوالی استفاده کردم و در نهایت تکنیک حذف کدهای مرده (Dead Code Elimination) رو روی خروجی اعمال کردم.

### ۴. مدیریت خطا (ERROR HANDLING)

![Abstract Syntax Tree diagram](لینک_عکس_درخت_در_صورت_وجود)

برای اعتبارسنجی سینتکس کدها، از ساختار درخت نحو انتزاعی (AST) استفاده کردم. درخت‌های AST ساختارهای داده‌ای هستند که به‌طور گسترده در کامپایلرها برای نمایش ساختار کد برنامه به کار می‌روند و معمولاً خروجی فاز تحلیل سینتکس یک کامپایلر هستند. این درخت اغلب به عنوان یک نمایش میانی از برنامه در چندین مرحله از کار کامپایلر عمل می‌کنه و تأثیر زیادی روی خروجی نهایی داره.

در این پروژه، درختی که جریان سینتکسی کد رو نشون میده تولید کردم و از فیلدهای `%left` و `%right` (انواع نمادهای گرامری) بهره بردم.
دلیل استفاده‌ام از AST این بود که بتونم منطق پارس کردن و اعتبارسنجی رو از بخش پیاده‌سازی جدا کنم. با این معماری، وقتی مشکلی در پارس کردن یک سینتکس عجیب به وجود میاد، مستقیماً به پارسر AST مراجعه می‌کنم و اگر بخشی از کد نتیجه‌ی مورد انتظار رو نده، سراغ کدی میرم که وظیفه‌ی تفسیر AST رو بر عهده داره.

## توسعه‌دهنده
* آریامهر ملکی
